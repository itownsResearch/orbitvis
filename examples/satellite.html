<html>
    <head>
        <title>Itowns - Globe</title>

        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="css/example.css">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="js/GUI/dat.gui/dat.gui.min.js"></script>
    </head>
    <body>
        <div id= "help" class="help">
                <p>Infos</p>
                <ul>
                </ul>
            </div>
        <div id="viewerDiv"></div>
        <script src="js/GUI/GuiTools.js"></script>
        <script src="../dist/itowns.js"></script>



        <script type="text/javascript"> let module = {exports:0};
         </script>
         <!-- <script src="https://rawgit.com/joshuaferrara/node-sgp4/master/sgp4.js"></script> -->
        <script src="https://cdn.jsdelivr.net/npm/sgp4@1.0.10/sgp4.min.js"></script>
        <script src="js/loading_screen.js"></script>
        <script src="../dist/debug.js"></script>
        <script type="text/javascript">

            // Define initial camera position
            // Coordinate can be found on https://www.geoportail.gouv.fr/carte
            // setting is "coordonnée geographiques en degres decimaux"
            var positionOnGlobe = { longitude: 4.22, latitude: 44.844, altitude: 10000000 };

            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');

            // Instanciate iTowns GlobeView*
            var globeView = new itowns.GlobeView(viewerDiv, positionOnGlobe, {noControls: false});
            
            var promises = [];

            var menuGlobe = new GuiTools('menuDiv', globeView);
            setupLoadingScreen(viewerDiv, globeView);

            // 1 hour coord of ISS. Quadruplet: t(seconds),x,y,z
            //const ISSCoordinates = [0,-622047.9073354374,-6741597.65930284,-461086.9956850074,30,-493039.72299258783,-6737579.000143799,-640501.0339055341,60,-363433.4463505021,-6726420.719653145,-819178.6750749751,90,-233345.8098409403,-6708137.878399649,-996914.4770435315,120,-102894.18352919456,-6682753.163696976,-1173504.0732091777,150,27803.523591679754,-6650296.861534489,-1348744.406698681,180,158628.9646266494,-6610806.82043792,-1522433.9630853767,210,289463.45619395445,-6564328.407171635,-1694373.001380792,240,420188.0804617068,-6510914.454355235,-1864363.7830384772,270,550683.7880246318,-6450625.200027885,-2032210.7987109432,300,680831.4997619174,-6383528.219373255,-2197720.992502438,330,810512.2120513102,-6309698.348331596,-2360703.983463278,360,939607.0993098159,-6229217.599628519,-2520972.2840740858,390,1067997.6182472648,-6142175.0709936675,-2678341.51547162,420,1195565.612238172,-6048666.845736591,-2832630.6191711137,450,1322193.414358034,-5948795.886092445,-2983662.0650438177,480,1447763.9531821357,-5842671.918661063,-3131262.055312529,510,1572160.8556718263,-5730411.31310205,-3275260.724331785,540,1695268.5512673538,-5612136.953454043,-3415492.333924258,570,1816972.3754129151,-5487978.102518657,-3551795.464049334,600,1937158.672712249,-5358070.259406887,-3684013.1985850353,630,2055714.899865219,-5222555.010309276,-3811993.306009483,660,2172529.7268557996,-5081579.873211856,-3935588.414773856,690,2287493.1399271167,-4935298.135340464,-4054656.1831643023,720,2400496.541403505,-4783868.685340561,-4169059.463456321,750,2511432.8499263227,-4627455.839015695,-4278666.460171239,780,2620196.599546448,-4466229.1593529675,-4383350.882250978,810,2726684.0378319994,-4300363.270941869,-4482992.088973792,840,2830793.2230919474,-4130037.668858983,-4577475.229440549,870,2932424.1194832567,-3955436.523000452,-4666691.375468249,900,3031478.6927928953,-3776748.4761532703,-4750537.647734659,930,3127861.002942716,-3594166.4385718238,-4828917.335025349,960,3221477.2960469583,-3407887.3773859707,-4901740.006442254,990,3312236.0949080964,-3218112.101673317,-4968921.61644043,1020,3400048.287168608,-3025045.044211064,-5030384.602567882,1050,3484827.2132879943,-2828894.0378909227,-5086057.975791369,1080,3566488.7512232885,-2629870.0900344113,-5135877.4032994695,1110,3644951.4000273533,-2428187.1526213223,-5179785.283682591,1140,3720136.3613534365,-2224061.8895719144,-5217730.81439823,1170,3791967.618939206,-2017713.4411902537,-5249670.051438508,1200,3860372.016071167,-1809363.1858502675,-5275565.961125859,1230,3925279.330441991,-1599234.5002437278,-5295388.46397168,1260,3986622.3476131847,-1387552.515815149,-5309114.470541782,1290,4044336.9312501587,-1174543.8751583765,-5316727.9092817195,1320,4098362.0913927853,-960436.4860200811,-5318219.746264177,1350,4148640.05014087,-745459.2742256974,-5313587.99682997,1380,4195116.304772993,-529841.9356265425,-5302837.729103542,1410,4237739.68824104,-313814.68714683066,-5285981.059373233,1440,4276462.426873973,-97608.01836807688,-5263037.139336053,1470,4311240.195487522,118547.55898022183,-5234032.135216145,1500,4342032.169446345,334421.7594799535,-5198999.198775582,1530,4368801.073929062,549784.773056322,-5157978.4302456835,1560,4391513.230197733,764407.5131503942,-5111016.833216451,1590,4410138.598835844,978061.8639511992,-5058168.261531201,1620,4424650.819842145,1190520.926617592,-4999493.358242907,1650,4435027.249842796,1401559.263000253,-4935059.486698114,1680,4441248.9955978235,1610953.1396364877,-4864940.653823659,1710,4443300.9447466,1818480.7676951052,-4789217.425700598,1740,4441171.79302222,2023922.5416444354,-4707976.835519076,1770,4434854.068066349,2227061.2753689946,-4621312.284016733,1800,4424344.150360626,2427682.4344555633,-4529323.432512483,1830,4409642.2897500275,2625574.3674427317,-4432116.088656149,1860,4390752.619469898,2820528.5317115607,-4329802.085023283,1890,4367683.166205153,3012339.716818381,-4222499.150693144,1920,4340445.85671692,3200806.263802785,-4110330.7759561455,1950,4309056.520915767,3385730.280433366,-3993426.070305395,1980,4273534.891194315,3566917.852348791,-3871919.613875268,2010,4233904.598970831,3744179.248685385,-3745951.3024975373,2040,4190193.1660140688,3917329.1249117586,-3615666.18655356,2070,4142431.99372352,4086186.7187128454,-3481214.303808665,2100,4090656.347983256,4250576.041664087,-3342750.5064217323,2130,4034905.3405223354,4410326.065301051,-3200434.2823307216,2160,3975221.9066219013,4565270.901579523,-3054429.571221065,2190,3911652.778952151,4715249.977708331,-2904904.575290966,2220,3844248.45883316,4860108.204085097,-2752031.565033829,2250,3773063.1817176584,4999696.137856629,-2595986.680263938,2280,3698154.8811602197,5133870.1383125605,-2436949.7266177097,2310,3619585.1481138985,5262492.516661908,-2275103.9677680368,2340,3537419.1865876773,5385431.6791033065,-2110635.913594626,2370,3451725.766951292,5502562.262241961,-1943735.1045581333,2400,3362577.173238705,5613765.263158348,-1774593.8925308166,2430,3270049.1493588495,5718928.160711771,-1603407.2183400735,2460,3174220.840600713,5817945.030418986,-1430372.3862861951,2490,3075174.7319207913,5910716.651796693,-1255688.835898492,2520,2972996.582811193,5997150.608222221,-1079557.9111978402,2550,2867775.358514719,6077161.379340178,-902182.6277366615,2580,2759603.1593001247,6150670.425128446,-723767.4376897546,2610,2648575.1436878275,6217606.263534311,-544517.993272196,2640,2534789.4512167815,6277904.538926717,-364640.9087621459,2670,2418347.1206673738,6331508.083318364,-184343.52140829526,2700,2299352.005453875,6378366.969487482,-3833.651502993307,2730,2177910.6859781803,6418438.556086537,176680.63809700613,2760,2054132.3787154136,6451687.52479368,356991.2827197488,2790,1928128.8438782997,6478085.908905793,536890.4566140245,2820,1800014.2873031204,6497613.114794819,716170.813389696,2850,1669905.2625388177,6510255.934275224,894625.7258798496,2880,1537920.5687975972,6516008.549350851,1072049.5251431968,2910,1404181.1466187914,6514872.5287554925,1248237.7383265346,2940,1268809.9710401131,6506856.816403947,1422987.325108084,2970,1131931.9420671028,6491977.711832281,1596096.9124448365,3000,993673.7743244327,6470258.842344474,1767367.027348856,3030,854163.881512698,6441731.127720982,1936600.3274202112,3060,713532.261733904,6406432.736441512,2103601.8288668245,3090,571910.3793131617,6364409.034326521,2268179.1317451214,3120,429431.0447209213,6315712.525346076,2430142.642158181,3150,286228.2941446062,6260402.784609852,2589305.7911527,3180,142437.26446363347,6198546.3839556305,2745485.250059641,3210,-1805.9304479046841,6130216.809774846,2898501.142027907,3240,-146364.32634215528,6055494.3735417435,3048177.2495056028,3270,-291100.23627789674,5974466.115009821,3194341.217427806,3300,-435875.3795359796,5887225.698223997,3336824.7518756306,3330,-580551.011915136,5793873.300452132,3475463.8139766906,3360,-724988.0556890133,5694515.494326957,3610098.8088228856,3390,-869047.2331091099,5589265.122977603,3740574.7691878797,3420,-1012589.1979721263,5478241.168769686,3866741.5338325696,3450,-1155474.6691555253,5361568.615480578,3988453.9201938715,3480,-1297564.5643778387,5239378.304203463,4105571.891258771,3510,-1438720.1343272969,5111806.783133337,4217960.716432687,3540,-1578803.097258138,4978996.151342345,4325491.126218557,3570,-1717675.7725488069,4841093.897158414,4428039.4605306005,3600,-1855201.216546484,4698252.730285688,4525487.810474162];

            function addLayerCb(layer) {
                return globeView.addLayer(layer);
            }
            // Add one imagery layer to the scene
            // This layer is defined in a json file but it could be defined as a plain js
            // object. See Layer* for more info.
            promises.push(itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(addLayerCb));
                        // Add two elevation layers.
            // These will deform iTowns globe geometry to represent terrain elevation.
            //promises.push(itowns.Fetcher.json('./layers/JSONLayers/WORLD_DTM.json').then(addLayerCb));
            //promises.push(itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addLayerCb));

            // Create satellite mesh (sphere)
            /*
                var THREE = itowns.THREE;
                var geometry = new THREE.SphereGeometry(80000, 12, 12);
                var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                var meshSatellite = new THREE.Mesh(geometry, material);
                globeView.scene.add(meshSatellite);
            */
            var THREE = itowns.THREE;
            var ISSCoordinates;
            var ISSSpeed;
            var liveOn = true;  // Real time positioning
            var overISS = false; // Lock camera to always view ISS 
            var lookAtISS = false;
            var satelliteModel;
            var controls;
            var globalTime;
            var trajectory;
            var precomputedTraj = {t0:0, interval:1, arrSatPos:[], arrSatSpeed:[]}; // Satellite precomputed positions, speeds and time interval
            var allTrajVisible = false;
            var lastPosition = new THREE.Vector3();  // Last known Satellite position
            var motionDirection = new THREE.Vector3(); // Satellite direction of motion
            var spotLight = new THREE.SpotLight( 0xfff1c9, 1., 500000, 60);  // SpotLight following ISS
            var solarPanels = []; //new THREE.Object3D(); // Future Reference to the satellite solar panels
            var sunSphere;
            var clouds;  // PointCloud sprite for volumetric clouds
            var radarTex; // Texture from radar satellite imagery for clouds
            var globalIterator = 0; // Time used for animation
            var incCloudSpeed = 1;  // Basic inc for clouds motion speed
            

            // Load a gltf model
            function loadModel(url){

                var loader = new THREE.GLTFLoader();
                // Load a glTF resource
                loader.load(
                    // resource URL
                    url,
                    // called when the resource is loaded
                    function ( gltf ) {

                        satelliteModel = gltf.scene;
                        satelliteModel.scale.set(100,100,100);
                        satelliteModel.updateMatrixWorld();
                        globeView.scene.add( satelliteModel );
                        satelliteModel.position.copy(ISSCoordinates);
                        //console.log("satelliteModel scale: ", satelliteModel.scale);

                        //satelliteModel.scale.set(100,100,100);

                        gltf.animations; // Array<THREE.AnimationClip>
                        gltf.scene; // THREE.Scene
                        gltf.scenes; // Array<THREE.Scene>
                        gltf.cameras; // Array<THREE.Camera>
                        gltf.asset; // Object

                        // We look for the 4 solar panel child mesh from the model
                        // We extract them (add a pivot to their vertices) so they have their own frame
                        satelliteModel.traverse( function(child) {
                            if (child.name.includes("ObjectsModulespaportinpapi-ani_w_goldcellslwo1")) {
                                for (var a = 0; a<4; ++a){
                                    var m = child.children[a];
                                    solarPanels.push(m);
                                    var pos = m.geometry.attributes.position.array;
                                    for(var i = 0; i< pos.length; i+=3){
                                        pos[i+2] += 1350;
                                    }
                                   m.position.z -=1350;
                                }
                            }

                            if (child.name.includes("ObjectsModulespastbdinpasi-ani_w_goldcellslwo1")) {
                                for (var a = 0; a<4; ++a){
                                    var m = child.children[a];
                                    solarPanels.push(m);
                                    var pos = m.geometry.attributes.position.array;
                                    for(var i = 0; i< pos.length; i+=3){
                                        pos[i+2] -= 1350;
                                    }
                                   m.position.z +=1350;
                                }
        
                            }

                             if (child.name.includes("ObjectsModulespaportoutpapo-ani_w_goldcellslwo1")) {
                                for (var a = 0; a<4; ++a){
                                    var m = child.children[a];
                                    solarPanels.push(m);
                                    var pos = m.geometry.attributes.position.array;
                                    for(var i = 0; i< pos.length; i+=3){
                                        pos[i+2] += 1850;
                                    }
                                   m.position.z -=1850;
                                }
                            }

                            if (child.name.includes("ObjectsModulespastbdoutpaso-ani_w_goldcellslwo1")) {
                                for (var a = 0; a<4; ++a){
                                    var m = child.children[a];
                                    solarPanels.push(m);
                                    var pos = m.geometry.attributes.position.array;
                                    for(var i = 0; i< pos.length; i+=3){
                                        pos[i+2] -= 1950;
                                    }
                                   m.position.z +=1950;
                                }
                            }

                        });

                       
                        
                    },
                    // called while loading is progressing
                    function ( xhr ) {

                        console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                    },
                    // called when loading has errors
                    function ( error ) {

                        console.log( 'An error happened' );

                    }
                );
            }

            function placeCamera(position, lookAt) {
                globeView.camera.camera3D.position.set(position.x, position.y, position.z);
                globeView.camera.camera3D.lookAt(lookAt);
                // create controls
                controls = new itowns.FirstPersonControls(globeView, { focusOnClick: true });
             //   debugGui.add(controls.options, 'moveSpeed', 1, 100).name('Movement speed');

                globeView.notifyChange(globeView.camera.camera3D);
             }


             function addCloudSatelliteImagery(){
                // Beware, the latitude values are acting weird. GetCap says minx="-90.0658" maxx="89.9779" but it seems unstable           
                radarTex = new THREE.TextureLoader().load("iss/clouds.png");
                    //" http://realearth.ssec.wisc.edu/api/image?products=globalir&bounds=-89,-180,89,180&width=2048&height=2048");
                var cloudMaterial = new THREE.MeshLambertMaterial({alphaMap:radarTex, lights:true, reflectivity: 1, transparent:true, opacity:1. });


                var sphere = new THREE.Mesh(new THREE.SphereGeometry(1.002, 64, 64).scale(6378137,6356752.3142451793,6378137), cloudMaterial);

                // Transforming sphere geometry for mercator projected texture
                for ( var i = 0, l = sphere.geometry.faceVertexUvs[ 0 ].length; i < l; i ++ ) {
                    for ( var j = 0, jl = sphere.geometry.faceVertexUvs[ 0 ][ i ].length; j < jl; j ++ ) {
                        var uv = sphere.geometry.faceVertexUvs[ 0 ][ i ][ j ];
                        var a = uv.y * Math.PI - Math.PI / 2;
                        a = Math.sin(a);
                        uv.y = Math.log( ( 1 + a ) / ( 1 - a ) ) / ( 6 * Math.PI ); // normally: / (4 * Math.PI)
                        uv.y += 0.5;
                    }
                }
                sphere.rotation.x = Math.PI/2;
                sphere.updateMatrixWorld();
                globeView.scene.add(sphere);
             }

            function getImageData( image ) {

                var canvas = document.createElement( 'canvas' );
                canvas.width = image.width;
                canvas.height = image.height;

                var context = canvas.getContext( '2d' );
                context.drawImage( image, 0, 0 );

                return context.getImageData( 0, 0, image.width, image.height );

            }

            function getPixel( imagedata, x, y ) {

                var position = ( x + imagedata.width * y ) * 4, data = imagedata.data;
                return { r: data[ position ], g: data[ position + 1 ], b: data[ position + 2 ], a: data[ position + 3 ] };

            }


            // Create a points cloud representing the satellite trajectory
            function createTrajectory3D(){
               
               const trajVertexShader = `
                    
                    #include <logdepthbuf_pars_vertex>

                   // attribute float alpha;
                    attribute float date;  // Milliseconds timing of position minus original launched time
                    attribute vec3 color;
                   // attribute vec3 posMotion;
                   
                    uniform vec4 origin;
                    uniform vec3 sunPos;
                    uniform bool allTrajVisible;
                    uniform sampler2D radarImg;
                    uniform float time;  // Current time in milliseconds minus orignal launched time
                    uniform vec3 currentSatPos;
                    varying float angle;  
                    varying vec3 vColor;  
                    varying float vDate;

                    void main() 
                    {

                        vColor = color;
                        vDate = date;

                        vec3 pos = position ;//+ (posMotion - position) * sin(scale * time/200.);

                        vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
                        float cameraDist = distance( mvPosition, origin );
                        float size = 40000000.0 / cameraDist;
                        gl_PointSize =  size;

                        if(time - date > 0.) gl_PointSize = max(4. * size - clamp((time - date) / 10000., size, 4. * size), size);

                        // Lighting
                        angle = dot(sunPos, normalize(pos));
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);
                        #include <logdepthbuf_vertex>
                    }
                        
                `;

                const trajFragmentShader = `
                    
                    #include <logdepthbuf_pars_fragment>

                    uniform sampler2D tDiffuse;
                    uniform bool allTrajVisible;
                    uniform float time;
                  //  uniform sampler2D radarImg;
                    uniform vec3 sunPos;
                    varying float angle;  
                    varying vec3 vColor;  
                    varying float vDate;

                    void main() 
                    {
                        #include <logdepthbuf_fragment>
                        vec4 col = texture2D(tDiffuse, gl_PointCoord);
                        gl_FragColor = vec4( vColor , col.a);   
                        if (!allTrajVisible && vDate - time > 0.) gl_FragColor.a = 0.;
                        //float alpha = gl_FragColor.a;
                        //gl_FragColor.a -= clamp((time - vDate) / 1000000.,0., alpha);
                        
                        
                    }
                        
                `;

                var geometry = new THREE.BufferGeometry();
                var positions = [];
                var colors = [];
                var alphas = [];
                var date = [];
                var dist = 6400000;
                var nbPoints = 1000000;
                var thresholdLuminance = 0.1;//.15;
               
                var arrPos = precomputedTraj.arrSatPos;
                var start = precomputedTraj.t0;
                var inc = precomputedTraj.interval;

                for (var i = 0; i < arrPos.length; ++i){
                    positions.push(arrPos[i].x, arrPos[i].y, arrPos[i].z);
                    date.push(i * inc);
                    var c = new THREE.Color().setHSL( i/arrPos.length, 0.9, 0.7 ); 
                    colors.push(c.r, c.g, c.b);
                }     

                geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
                geometry.addAttribute( 'date', new THREE.Float32BufferAttribute( date, 1 ) );
                geometry.computeBoundingSphere();
                        
                var shaderMaterial = new THREE.ShaderMaterial( {

                    uniforms: { 
                        tDiffuse: {type: "t", value: new THREE.TextureLoader().load("iss/spark.png")},
                        radarImg: {type: "t", value: radarTex},
                        allTrajVisible : {value: allTrajVisible},
                        sunPos: new THREE.Uniform(globeView.sun.position),
                        time: new THREE.Uniform(globalTime),
                        currentSatPos:  {value: ISSCoordinates},
                    },
                    vertexShader: trajVertexShader,
                    fragmentShader: trajFragmentShader,

                } );

                shaderMaterial.transparent = true;
                shaderMaterial.sortParticles = true;
                shaderMaterial.sizeAttenuation = false;
                shaderMaterial.depthWrite = false;
                // shaderMaterial.blending = THREE.NormalBlending;
        
                trajectory = new THREE.Points( geometry, shaderMaterial);
                globeView.scene.add( trajectory );
            }



            // Create clouds using points out of a Radar satellite image
            function addVolumetricClouds(){

                 const cloudsVertexShader = `
                    
                    #include <logdepthbuf_pars_vertex>

                    attribute float alpha;
                    attribute float scale;
                    attribute vec3 posMotion;
                    uniform vec4 origin;
                    uniform vec3 sunPos;
                    uniform sampler2D radarImg;
                    uniform float time;
                    varying float angle;  
                    varying float vAlpha;  

                    void main() 
                    {
                      
                        vAlpha = alpha;

                        vec3 pos = position + (posMotion - position) * sin(scale * time/200.);

                        vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
                        float cameraDist = distance( mvPosition, origin );
                        gl_PointSize = max(scale,0.6) * 210000000.0 / cameraDist;
                    
                        // Lighting
                        angle = dot(sunPos, normalize(pos));
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);
                        #include <logdepthbuf_vertex>
                    }
                        
                `;

                const cloudsFragmentShader = `
                    
                    #include <logdepthbuf_pars_fragment>
                    //varying vec3 vNormal;
                    //varying float distStart;

                    
                    uniform sampler2D tDiffuse;
                    uniform sampler2D radarImg;
                    uniform vec3 sunPos;
                    varying float angle;  
                    varying float vAlpha;  

                    void main() 
                    {
                        #include <logdepthbuf_fragment>
                        vec4 col = texture2D(tDiffuse, gl_PointCoord);
                        gl_FragColor = vec4(col.rgb * 1.2, col.a);     
                        gl_FragColor.a *=  pow(angle, 2.) *  vAlpha * 2.;
                        if (angle < 0. ) gl_FragColor.a = 0.;
                    }
                        
                `;

                var geometry = new THREE.BufferGeometry();
                var positions = [];
                var posMotions = [];
                var alphas = [];
                var scales = [];
                var dist = 6400000;
                var nbPoints = 1000000;
                var thresholdLuminance = 0.1; // .15;


                radarTex = new THREE.TextureLoader().load("https://realearth.ssec.wisc.edu/api/image?products=globalir&bounds=-89,-180,89,180&width=2048&height=2048",// onLoad callback
                    function ( texture ) {
                    
                        var imagedata = getImageData( texture.image );
                        var w = imagedata.width;
                        var h = imagedata.height;
                        var minY = 0; // imagedata.width / 7;
                        var maxY = h; // 6 * imagedata.width / 7;

                        for(var i = 0; i < w; i+=1){

                            for(var j = minY; j < maxY; j+=1){

                                    var a = (j/h) * Math.PI - Math.PI / 2;
                                    a = Math.sin(a);
                                    var uvy = Math.log(( 1 + a ) / ( 1 - a )) / (6* Math.PI); // normally: / (4 * Math.PI)
                                    uvy += 0.5;       
                                    // Get pixel real:
                                    var p = getPixel(imagedata, i, Math.floor(uvy * h));
                                    // Enhance contrast using a Sigmoid function
                                    
                                    var v = p.r / 255; if (i == 500 && j == 50 ) console.log("a",p,v);
                                    //  v = v*2 - 1;
                                    //  v = 1 / (1 + Math.exp(-v)) -0.5; 
                                    v = 0.5 + 2 * (v - 0.5);
                                    if (i == 500 && j == 50 ) console.log("b",p,v);
                                    // we subsample more around the poles and filter light clouds
                                    if(v > thresholdLuminance && Math.random() * j > h/12 &&  (1+Math.random()) * j <  6*h/8 /*&& Math.random()>0.5*/){
                                        // We got coords i,y between 0,1
                                        var teta = Math.PI + i/w * 2 * Math.PI;
                                        var phi  = (j/h) * Math.PI; //uvy * Math.PI;
                                        // Introduce noise
                                        teta += Math.random() * 0.005;
                                        phi += Math.random() * 0.005;
                                        // Using spherical coords we compute cartesian coordinates
                                        var d = dist + Math.random() * 2000;  // add noise to altitude and other coords optionally
                                        var x = d * Math.sin(phi) * Math.cos(teta) //+ Math.random() * 10000;
                                        var y = d * Math.sin(phi) * Math.sin(teta) //+ Math.random() * 10000;
                                        var z = d * Math.cos(phi) //+ Math.random() * 100;
                                        // Ugly motion position precomputed
                                        var phi2 = phi + Math.random()/100;
                                        var teta2 =  teta + Math.random()/100;
                                        var d2 = d + Math.random() * 2000;
                                        var x2 = d2 * Math.sin(phi2) * Math.cos(teta2) //+ Math.random() * 10000;
                                        var y2 = d2 * Math.sin(phi2) * Math.sin(teta2) //+ Math.random() * 10000;
                                        var z2 = d2 * Math.cos(phi2) //+ Math.random() * 100;;
                                        positions.push( x, y, z );
                                        posMotions.push(x2, y2, z2);
                                        alphas.push( v );
                                        scales.push(Math.random()); // Used to introduce irregular clouds size and also for motion
                                    }
                            
                            }

                        }
                        console.log(positions.length/3);
                        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
                        geometry.addAttribute( 'posMotion', new THREE.Float32BufferAttribute( posMotions, 3 ) );
                        geometry.addAttribute( 'alpha', new THREE.Float32BufferAttribute( alphas, 1 ) );
                        geometry.addAttribute( 'scale', new THREE.Float32BufferAttribute( scales, 1 ) );
                        geometry.computeBoundingSphere();
                        
                        var shaderMaterial = new THREE.ShaderMaterial( {

                            uniforms: { 
                                tDiffuse: {type: "t", value: new THREE.TextureLoader().load("iss/cloudTexture.png")},
                                radarImg: {type: "t", value: radarTex},
                                sunPos: new THREE.Uniform(globeView.sun.position),
                                time: new THREE.Uniform(globalIterator)
                            },
                            vertexShader: cloudsVertexShader,
                            fragmentShader: cloudsFragmentShader,

                        } );
                        shaderMaterial.transparent = true;
                        shaderMaterial.sortParticles = true;
                        shaderMaterial.sizeAttenuation = false;
                        shaderMaterial.depthWrite = false;
                        shaderMaterial.blending = THREE.NormalBlending;
                
                        clouds = new THREE.Points( geometry, shaderMaterial/*starsMaterial*/ );
                        //clouds.rotation.x = Math.PI/2;
                       // clouds.updateMatrixWorld();
                        globeView.scene.add( clouds );

                    },

                );
                


                // We create one 3D particle for each pixel of cloud in the image using an intensity check and specifying an alpha
            //    console.log(radarTex);
/*
				for ( var i = 0; i < nbPoints; i ++ ) {
                    var d = dist + Math.random() * 500;
                    var teta = Math.random() * 2 * Math.PI;
                    var phi  = Math.random() * Math.PI;
                    var x = d * Math.sin(teta) * Math.cos(phi);
                    var y = d * Math.sin(teta) * Math.sin(phi);
                    var z = d * Math.cos(teta);
                    positions.push( x, y, z );
                    alphas.push( new THREE.Vector2(teta,phi) );
                }
                */


             }


             function addStars(){
                var texture = new THREE.TextureLoader().load("iss/starmap_8k.jpg");
                var starsMaterial = new THREE.MeshBasicMaterial({map:texture, side:THREE.DoubleSide, transparent:true, opacity: 0.5, blending:THREE.NoBlending});
                var sphere = new THREE.Mesh(new THREE.SphereGeometry(250000000, 64, 64), starsMaterial);
                globeView.scene.add(sphere);
             }

             function addSun(){
				sunSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 200000, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				//globeView.scene.add( sunSphere );
             }


            function getsunpos(){
                date = new Date();
                var rad = 0.017453292519943295;
                // based on NOAA solar calculations
                var mins_past_midnight = (date.getUTCHours() * 60 + date.getUTCMinutes()) / 1440;
                var jc = (((date.getTime() / 86400000.0) + 2440587.5) - 2451545)/36525;
                var mean_long_sun = (280.46646+jc*(36000.76983+jc*0.0003032)) % 360;
                var mean_anom_sun = 357.52911+jc*(35999.05029-0.0001537*jc);
                var sun_eq = Math.sin(rad*mean_anom_sun)*(1.914602-jc*(0.004817+0.000014*jc))+Math.sin(rad*2*mean_anom_sun)*(0.019993-0.000101*jc)+Math.sin(rad*3*mean_anom_sun)*0.000289;
                var sun_true_long = mean_long_sun + sun_eq;
                var sun_app_long = sun_true_long - 0.00569 - 0.00478*Math.sin(rad*125.04-1934.136*jc);
                var mean_obliq_ecliptic = 23+(26+((21.448-jc*(46.815+jc*(0.00059-jc*0.001813))))/60)/60;
                var obliq_corr = mean_obliq_ecliptic + 0.00256*Math.cos(rad*125.04-1934.136*jc);
                var lat = Math.asin(Math.sin(rad*obliq_corr)*Math.sin(rad*sun_app_long)) / rad;
                var eccent = 0.016708634-jc*(0.000042037+0.0000001267*jc);
                var y = Math.tan(rad*(obliq_corr/2))*Math.tan(rad*(obliq_corr/2));
                var rq_of_time = 4*((y*Math.sin(2*rad*mean_long_sun)-2*eccent*Math.sin(rad*mean_anom_sun)+4*eccent*y*Math.sin(rad*mean_anom_sun)*Math.cos(2*rad*mean_long_sun)-0.5*y*y*Math.sin(4*rad*mean_long_sun)-1.25*eccent*eccent*Math.sin(2*rad*mean_anom_sun))/rad);
                var true_solar_time = (mins_past_midnight*1440+rq_of_time) % 1440;
                var lng = -((true_solar_time/4 < 0) ? true_solar_time/4 + 180 : true_solar_time/4 - 180);
                return {sunlat:lat, sunlon:lng};
            }

            function changeSpeedTime(){
                console.log("changetime",liveOn);
                liveOn = !liveOn;
                liveOn ? incCloudSpeed = 1 : incCloudSpeed = 10;

            }

            function changeCamPosition(){
                overISS = !overISS;
                // globeView.controls.setRange(120000,true); // Nice slow motion
                // globeView.controls.setTilt(60, true);
                //globeView.controls.setCameraTargetPosition(ISSCoordinates, true);

            }

            function camLookAtISS(){
                lookAtISS = !lookAtISS;
            }

            

            // Function to precompute satetllite positions for satellite satRec between two dates t0, t1 (in milliseconds since 70') every t milliseconds
            //{t0:0, interval:1, arrSatPos:[]}; // Satellite precomputed positions object
            function precomputeSatPos(satRec, t0, t1, t){
                precomputedTraj.interval = t;
                precomputedTraj.t0 = t0;
                var arrSatPos = precomputedTraj.arrSatPos;
                var arrSatSpeed = precomputedTraj.arrSatSpeed;
                //console.log(t0, t1, t);
                for(var i = t0; i < t1; i += t){
                    var time = new Date(i);
                    //time.setSeconds(time.getSeconds() + t);
                   // console.log(t0, time);
                     // This will contain ECI (http://en.wikipedia.org/wiki/Earth-centered_inertial) coordinates of position and velocity of the satellite
                     var positionAndVelocity = SGP4.propogate(satRec, time.getUTCFullYear(), time.getUTCMonth() + 1, time.getUTCDate(), time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds());
                    // GMST required 
                    var gmst = SGP4.gstimeFromDate(time.getUTCFullYear(), time.getUTCMonth() + 1, time.getUTCDate(), time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds());
                    // Compute Earth centered frame coordinates
                    var geodeticCoordinates = SGP4.eciToGeodetic(positionAndVelocity.position, gmst);
                    var posECF = SGP4.eciToEcf(positionAndVelocity.position, gmst);
                    ISSCoordinates = new THREE.Vector3(posECF.x, posECF.y, posECF.z).multiplyScalar(1000);
                    arrSatPos.push(ISSCoordinates);
                    arrSatSpeed.push(geodeticCoordinates.velocity * 3600);
                }
                console.log(precomputedTraj);
            }


            // Function to access precomputed position and speed and add interpolation
            function getPosAndSpeedAtTime(t){
                var p = precomputedTraj;
                var pos;
                var speed;
                if(t > p.t0){
                    var v = (t - p.t0) / (p.interval);
                    var ind = Math.floor(v);
                    var co = v - ind;
                    var p1 = p.arrSatPos[ind];
                    var p2 = p.arrSatPos[ind + 1];
                    var px = p2.clone().sub(p1);
                    pos = p1.clone().add( px.multiplyScalar(co));
                    speed = p.arrSatSpeed[ind];
                }
                 else{
                    pos = p.arrSatPos[0];
                    speed = p.arrSatSpeed[0];
                 }

                return {pos:pos, speed:speed};
            }


            function showAllTraj(){
                allTrajVisible = !allTrajVisible;
                trajectory.material.uniforms.allTrajVisible.value = allTrajVisible;
            }


            // Listen for globe full initialisation event
            globeView.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function globeInitialized() {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');
                Promise.all(promises).then(function init() {
                    menuGlobe.addImageryLayersGUI(globeView.getLayers(function filterColor(l) { return l.type === 'color'; }));
                    menuGlobe.addGUI('RealisticLighting', false, globeView.setRealisticLightingOn.bind(globeView));
                    menuGlobe.addGUI('Time x 30', false, changeSpeedTime);
                    menuGlobe.addGUI('Over ISS', false, changeCamPosition);
                    menuGlobe.addGUI('look at ISS', false, camLookAtISS);
                    menuGlobe.addGUI('24h trajectory', false, showAllTraj);


                    // Sample ISS TLE Data from 24 august 2018 https://www.celestrak.com/NORAD/elements/stations.txt
                    var issLine1 = "1 25544U 98067A   18235.94006556  .00000805  00000-0  19613-4 0  9991";
                    var issLine2 = "2 25544  51.6425  41.0532 0005980  86.9575  34.3421 15.53864358129054";

                    // Create a satellite record
                    var issSatRec = SGP4.twoline2rv(issLine1, issLine2, SGP4.wgs84());
                    // Precompute trajectory
                    var t = Date.now();  // In milliseconds since midnight January 1, 1970
                    var duration = 24 * 3600 * 1000; // One day duration in milliseconds
                   // var b = Date.now();
                    var endDate = t + duration;//new Date(t).setSeconds(t.getSeconds() + duration); console.log(t.getSeconds(), endDate);
                    precomputeSatPos(issSatRec, t, endDate, 1000);



                    console.log(globeView.camera);
                    globeView.scene.add( spotLight );


                //    var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );

                    console.log(globeView);
              //      globeView.scene.add( directionalLight );

                    // Add clouds satellite IR Imagery
                    // addCloudSatelliteImagery();
                    addSun();
                    addVolumetricClouds();

                    // Show trajectory
                    createTrajectory3D(precomputedTraj);

                    // Add stars
                    //addStars();
                    //var cam = globeView.camera.camera3D.clone();
                   // globeView.camera.camera3D = null;
                   // globeView.camera.camera3D = new THREE.PerspectiveCamera( 45, 1920 / 1080, 10, 10000000 );
                /*    globeView.camera.camera3D.position.set(8000000,8000000,8000000);
                    globeView.camera.camera3D.updateMatrixWorld(true);
                    globeView.camera.camera3D.lookAt( {x: 2511898.50816151, y: -3997639.5639961394, z: -4877003.964348924});//new itowns.THREE.Vector3(0, 0, 0));
*/
/*
                    controls = new THREE.OrbitControls(globeView.camera.camera3D, viewerDiv);
                    controls.minDistance = 1;
                    controls.addEventListener('change', function _() { globeView.notifyChange(globeView.camera.camera3D); });
                    globeView.controls = controls;
             */       
                    var inc = 0;

                    
                            // UGLY Line
                            var material = new THREE.LineBasicMaterial({
                                color: 0xaaaaaa,
                                transparent:true,
                                depthTest:false
                            });

                            var geometry = new THREE.Geometry();
                            var geometryS = new THREE.SphereGeometry(12000, 6, 6);
                            var materialS = new THREE.MeshBasicMaterial({ color: 0xf4427d, transparent: true, opacity: 0.6 });
                           // var line = new THREE.Line( geometry, material );
                          //  globeView.scene.add( line );


                    var pivotObj = new THREE.Object3D();


                    // This will compute position every second
                    function getCurrentPosition() {
          
                        var now = Date.now();
                        inc += 1000;  // 1 second later every frame refresh
                        if(liveOn) inc = 0;
                        // ugly increment for faster
                        now += inc;
                        var oldTime = now -  5*1000; // 5 seconds earlier
                        globalTime = now;
                        var speedAndPos = getPosAndSpeedAtTime(now);
                        ISSCoordinates = speedAndPos.pos;
                        ISSSpeed = speedAndPos.speed;
                        lastPosition = getPosAndSpeedAtTime(oldTime).pos;
 
                        // We compute satellite position and orientation
                        if(satelliteModel){

                            satelliteModel.position.copy(ISSCoordinates);
                            satelliteModel.up = lastPosition;
                            satelliteModel.lookAt(new THREE.Vector3(0,0,0));
                            satelliteModel.rotateX(-Math.PI / 2);
                            satelliteModel.rotateY(Math.PI / 2);
                            satelliteModel.updateMatrixWorld();
                         

                            // We compute camera pos/ori depending on control options
                            //   globeView.camera.camera3D.position.copy(ISSCoordinates.multiplyScalar(1.1));
                            if(lookAtISS) 
                                globeView.camera.camera3D.lookAt(ISSCoordinates);
                            else
                            if(overISS){
                               // var 
                                globeView.camera.camera3D.lookAt(ISSCoordinates);
                                globeView.camera.camera3D.position.copy(ISSCoordinates.clone().multiplyScalar(1.10));
                            }
                            //   globeView.camera.camera3D.updateMatrixWorld(true);
                            
                            //   globeView.notifyChange(globeView.camera.camera3D);



                        /*
                            // Drawing the trajectory DEBUG
                            var sphere = new THREE.Mesh(geometryS, materialS);
                            sphere.position.copy(ISSCoordinates);
                            sphere.updateMatrixWorld();
                            globeView.scene.add(sphere);
                        */
                            // Illuminate the satellite
                            spotLight.position.copy(ISSCoordinates.clone().multiplyScalar(1.02));
                            spotLight.updateMatrixWorld();

                            globeView.setSunPositionAtTime(new Date(now));
                            for(var i = 0; i < solarPanels.length; ++i){
                                solarPanels[i].lookAt(globeView.sun.position);
                              //  solarPanels[i].updateMatrixWorld();
                               // solarPanels[i].rotation.x += 0.1;
                              //  solarPanels[i].updateMatrixWorld();
                            }
                           // console.log(satelliteModel.rotation.z /*, solarPanels[0].rotation.z*/);
                            sunSphere.position.copy(globeView.sun.position.clone().multiplyScalar(100000000));
                            sunSphere.updateMatrixWorld();

                            if(clouds){
                                clouds.material.uniforms.sunPos.value = globeView.sun.position;
                                clouds.material.uniforms.time.value = globalIterator;
                                globalIterator += incCloudSpeed;
                            }

                            if(trajectory){
                                trajectory.material.uniforms.currentSatPos.value = ISSCoordinates;
                                trajectory.material.uniforms.time.value = globalTime - precomputedTraj.t0;
                            }

                            // Display Infos
                            document.getElementById('help').innerHTML = new Date(now).toDateString()+ " "+ new Date(now).toLocaleTimeString() + "<br />Speed: " + Number(ISSSpeed).toFixed(2) + "km/h";
                           
                            /*
                            solarPanels[0].rotation.x += 0.1;
                            solarPanels[0].updateMatrixWorld();
                            */
                          //  solarPanels[1].rotation.x += 0.1;
                            

                            //solarPanels.lookAt(globeView.sun.position);
                   /*         
                            // get position of the solar panel center
                            var pivot = satelliteModel.position.clone().sub(new THREE.Vector3(0, 0, 1211.0985107421875));
                            //pivotObj = new THREE.Object3D();
                            
                            pivotObj.position.copy(pivot);
                            pivotObj.updateMatrixWorld();
                            globeView.scene.add(pivotObj);
                            
                            pivotObj.add(solarPanels);

                            pivotObj.rotation.x += 0.1;
                          //  solarPanels.rotation.x += 0.1;

                            var s = new THREE.Mesh(geometryS, new THREE.MeshBasicMaterial());
                            s.position.copy(pivot);
                            s.updateMatrixWorld();
                            globeView.scene.add(s);
                    */        
                        }
                        setTimeout(getCurrentPosition, 30);
                    
                    }
                    getCurrentPosition();



                    //globeView.controls.setTilt(60, true);
                }).catch(console.error);
            });

            var script = document.createElement('script');
            //var THREE = itowns.THREE;
            script.type = 'text/javascript';
            script.src = 'https://cdn.rawgit.com/mrdoob/three.js/r' + THREE.REVISION + '/examples/js/loaders/GLTFLoader.js';
            script.onload = function l() {
                loadModel('iss/scene.gltf');
            };
            document.body.appendChild(script);
            
            var script2 = document.createElement('script');
            //var THREE = itowns.THREE;
            script2.type = 'text/javascript';
            script2.src = 'https://cdn.rawgit.com/mrdoob/three.js/r' + THREE.REVISION + '/examples/js/controls/OrbitControls.js';
            document.body.appendChild(script2);
        </script>
    </body>
</html>
